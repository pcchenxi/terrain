#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_cloud.h>
#include <pcl_ros/transforms.h>

#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#include "terrain_function_sturcture.h"

using namespace std;
using namespace cv;

struct Vec3
{
    float x;
    float y;
    float z;
 
    const Vec3 operator-( const Vec3& a )
    {
        Vec3 v;
        v.x = x - a.x;
        v.y = y - a.y;
	v.z = z - a.z;
 
        return v;
    }
 
    const Vec3 operator*( float a ) const
    {
        Vec3 v;
        v.x = x * a;
        v.y = y * a;
	v.z = z * a;
 
        return v;
    }
};
 
float Dot( const Vec3& a, const Vec3& b )
{
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

float DistancePtLine( Vec3 a, Vec3 b, Vec3 p )
{
    Vec3 n = b - a;
    Vec3 pa = a - p;
    Vec3 c = n * (Dot( pa, n ) / Dot( n, n ));
    Vec3 d = pa - c;
    return abs(d.z);
    //return sqrt( Dot( d, d ) );
}

class Filter_Continuity
{
    public:
        float max_continuity;

        Filter_Continuity(int num_one_set );
        int point_num_h;
        Feature* filtering_one_set(pcl::PointCloud<pcl::PointXYZRGB> velodyne_set, Feature *feature_set);
        Feature** filtering_all_sets(pcl::PointCloud<pcl::PointXYZRGB> *velodyne_sets, Feature **feature_set);

        float get_varience( Feature *feature_set, int start_index, int size);
        float get_varience_height( Feature *feature_set, pcl::PointCloud<pcl::PointXYZRGB> velodyne_set, int start_index, int size);

        void  get_min_max_height(pcl::PointCloud<pcl::PointXYZRGB> velodyne_set
                , int start_index, int size, float &min_height, float &max_height);

        pcl::PointCloud<pcl::PointXYZRGB> color_one_set(pcl::PointCloud<pcl::PointXYZRGB>  velodyne_sets, Feature  *feature_set);
        pcl::PointCloud<pcl::PointXYZRGB> color_all_sets(pcl::PointCloud<pcl::PointXYZRGB> *velodyne_sets, Feature **feature_set);


};

pcl::PointCloud<pcl::PointXYZRGB> Filter_Continuity::color_one_set(pcl::PointCloud<pcl::PointXYZRGB> velodyne_sets, Feature *feature_set)
{
    //cout << max_continuity << endl;
    float color_step = 255 * 255;
    for(int i = 0; i<720; i++)
    {
        if(feature_set[i].radius == 0)
            continue;

        float continuity_prob = feature_set[i].continuity_prob;

        float color = continuity_prob/max_continuity * 255;

        //cout << continuity_prob << endl;
        // float color = continuity_prob*255 * 10;
        // int b = color / color_step;
        // float color_left = color - b*color_step;
        // int g = color_left / 255;
        // int r = color_left - g*255;
        //velodyne_sets.points[i].r = continuity_prob/max_continuity * 255;

	if(continuity_prob < 0.01)
	{
	    velodyne_sets.points[i].r = color;
            velodyne_sets.points[i].g = 0;
      	    velodyne_sets.points[i].b = 0;	
	}
	else if(continuity_prob < 0.02)
	{
	    velodyne_sets.points[i].r = 255;
            velodyne_sets.points[i].g = color;
      	    velodyne_sets.points[i].b = 0;	
	}
	else
	{
	    velodyne_sets.points[i].r = 0;
            velodyne_sets.points[i].g = 255;
      	    velodyne_sets.points[i].b = color;	
	}


        // velodyne_sets.points[i].g = g;
        // velodyne_sets.points[i].b = b;
    }

    return velodyne_sets;
}

pcl::PointCloud<pcl::PointXYZRGB> Filter_Continuity::color_all_sets(pcl::PointCloud<pcl::PointXYZRGB> *velodyne_sets, Feature **feature_set)
{
    pcl::PointCloud<pcl::PointXYZRGB> result;

    for(int i = 0; i<1; i++)
    {
        velodyne_sets[i] = color_one_set(velodyne_sets[i], feature_set[i]);
        result += velodyne_sets[i];
    }

    return result;
}


Filter_Continuity::Filter_Continuity(int num_one_set = 720)
{
    max_continuity = 0;
    point_num_h = num_one_set;
}

void Filter_Continuity::get_min_max_height(pcl::PointCloud<pcl::PointXYZRGB> velodyne_set
                , int start_index, int size, float &min_height, float &max_height)
{
    min_height = 999;
    max_height = -999;

    int start = start_index - size/2;
    int end = start_index + size/2 + 1;

    if(start < 0)
        start = start + velodyne_set.points.size();
    if(end > velodyne_set.points.size()-1)
        end = velodyne_set.points.size()-1;

    for(int i = start; i < end; i++)
    {
        int index = i % velodyne_set.points.size();

        if(velodyne_set.points[index].x == 0 && velodyne_set.points[index].y == 0)
            continue;

        float height = velodyne_set.points[index].z;

        if(height < min_height)
            min_height = height;
        if(height > max_height)
            max_height = height;
    }
}

void dft_process(Mat I)
{
    Mat padded;                            //expand input image to optimal size
    int m = getOptimalDFTSize( I.rows );
    int n = getOptimalDFTSize( I.cols ); // on the border add zero values
    copyMakeBorder(I, padded, 0, m - I.rows, 0, n - I.cols, BORDER_CONSTANT, Scalar::all(0));

    //cout << m << " n: " << n << endl;

    Mat planes[] = {Mat_<float>(I), Mat::zeros(I.size(), CV_32F)};
    Mat complexI;
    merge(planes, 2, complexI);         // Add to the expanded another plane with zeros

    dft(complexI, complexI);            // this way the result may fit in the source matrix

    // compute the magnitude and switch to logarithmic scale
    // => log(1 + sqrt(Re(DFT(I))^2 + Im(DFT(I))^2))
    split(complexI, planes);                   // planes[0] = Re(DFT(I), planes[1] = Im(DFT(I))
    magnitude(planes[0], planes[1], planes[0]);// planes[0] = magnitude
    Mat magI = planes[0];

    magI += Scalar::all(1);                    // switch to logarithmic scale
    log(magI, magI);

    // crop the spectrum, if it has an odd number of rows or columns
    magI = magI(Rect(0, 0, magI.cols & -2, magI.rows & -2));

    // rearrange the quadrants of Fourier image  so that the origin is at the image center
   // int cx = magI.cols/2;
   // int cy = magI.rows/2;

   // Mat q0(magI, Rect(0, 0, cx, cy));   // Top-Left - Create a ROI per quadrant
   // Mat q1(magI, Rect(cx, 0, cx, cy));  // Top-Right
   // Mat q2(magI, Rect(0, cy, cx, cy));  // Bottom-Left
   // Mat q3(magI, Rect(cx, cy, cx, cy)); // Bottom-Right

   // Mat tmp;                           // swap quadrants (Top-Left with Bottom-Right)
   // q0.copyTo(tmp);
   // q3.copyTo(q0);
  //  tmp.copyTo(q3);

  //  q1.copyTo(tmp);                    // swap quadrant (Top-Right with Bottom-Left)
   // q2.copyTo(q1);
  //  tmp.copyTo(q2);

    normalize(magI, magI, 0, 1, CV_MINMAX); // Transform the matrix with float values into a
                                            // viewable image form (float between values 0 and 1).

  //  imshow("Input Image"       , I   );    // Show the result
    imshow("spectrum magnitude", magI);
	
    cout << magI << endl;

    //cout << magI.ptr<float>(0)[1] << " " << magI.ptr<float>(0)[2] << " " << magI.ptr<float>(0)[3] << " " << magI.ptr<float>(0)[4] << " " << magI.ptr<float>(0)[5] << " " << magI.ptr<float>(0)[6] << endl;
    waitKey(3);

}

float Filter_Continuity::get_varience_height( Feature *feature_set, pcl::PointCloud<pcl::PointXYZRGB> velodyne_set, int start_index, int size)
{

    Mat height_diff(3, size+1, CV_8UC1, Scalar( 0));

    float sum = 0;
    float varience = 0;
    float valud_count = 0;

    float avg = feature_set[start_index].radius;
    float avg_x = velodyne_set.points[start_index].x;
    float avg_y = velodyne_set.points[start_index].y;
    float avg_z = velodyne_set.points[start_index].z;

    int img_index = -1;
    int start = start_index - size/2;
    int end = start_index + size/2;

    if(start < 0)
        start = 0;
    if(end > velodyne_set.points.size()-1)
        end = velodyne_set.points.size()-1;

    Vec3 a, b; 
    a.x = velodyne_set.points[start].x;
    a.y = velodyne_set.points[start].y;
    a.z = velodyne_set.points[start].z;

    b.x = velodyne_set.points[end].x;
    b.y = velodyne_set.points[end].y;
    b.z = velodyne_set.points[end].z;

    for(int i = start; i < end; i++)
    {
	img_index ++;
        float r = feature_set[i].radius;
        if(r == 0)
            continue;

        Vec3 p;
        p.x = velodyne_set.points[i].x;
        p.y = velodyne_set.points[i].y;
        p.z = velodyne_set.points[i].z;

	float dist = DistancePtLine(a, b, p);
        valud_count ++;
	//cout << dist << endl;
        if(dist > 0.1)
            dist = 0.1;

	int img_v = dist * 2000;
	if(img_v > 255)
		img_v = 255;
	if(img_v < 1)
		img_v = 0;

	height_diff.ptr<uchar>(0)[img_index] = img_v;
	height_diff.ptr<uchar>(1)[img_index] = img_v;
	height_diff.ptr<uchar>(2)[img_index] = img_v;

	//cout << img_index << endl;
	varience += dist;
    }
    //if(valud_count < 5)
    //	varience = 0;
    //cout << valud_count << " varience: " << varience << endl;

    varience = varience/valud_count;

    dft_process(height_diff);
    //cout << valud_count << " varience: " << varience << endl;
    return varience;

}

float Filter_Continuity::get_varience( Feature *feature_set, int start_index, int size)
{
    float sum = 0;
    float varience = 0;
    int   valud_count = 0;

    float avg = feature_set[start_index].radius;

    int start = start_index - size/2;
    int end = start_index + size/2 + 1;

    if(start < 0)
        start = start + point_num_h;
    if(end >= point_num_h)
        end = point_num_h - 1;

    //cout << "start: " << start << "  end: " << end << endl;
    for(int i = start; i < end; i++)
    {
        int index = i % point_num_h;
        float r = feature_set[index].radius;
        //cout << "avg: " << avg << "  r: " << r << endl;
        if(r == 0)
            continue;

        valud_count ++;

        float diff = (r - avg);
	float diff_abs = abs(diff);

	if(diff < 0 && diff_abs > 0.1)
	    continue;

        if(diff_abs > 0.2)
        {
            diff = 0.2;
          //  break;
        }
	varience += diff*diff;
    }

  //  if(valud_count < 3)
  //      varience = 0;
  //  cout << "varience: " << varience << endl;
 //   if(varience > 0.025)
//	varience = 1;
    return varience;
}

Feature ** Filter_Continuity::filtering_all_sets(pcl::PointCloud<pcl::PointXYZRGB> *velodyne_sets, Feature **feature_set)
{
        max_continuity = 0;
    pcl::PointCloud<pcl::PointXYZRGB> result;
    for(int i = 0; i<16; i++)
    {
        feature_set[i] = filtering_one_set(velodyne_sets[i], feature_set[i]);
        //result += velodyne_sets[i];
    }

    return feature_set;
}

pcl::PointXYZRGB set_point_color(pcl::PointXYZRGB point, int r, int g, int b)
{
    point.r = r;
    point.g = g;
    point.b = b;

    return point;
}

Feature * Filter_Continuity::filtering_one_set(pcl::PointCloud<pcl::PointXYZRGB> velodyne_set, Feature *feature_set)
{
    int start_index = 0;
    int pre_index = 0;
    float color_step = 255 * 255;

    for(int i = 0; i < velodyne_set.points.size(); i = i+1)
    {
        float varience = 0;
        if(feature_set[i].radius == 0)
            continue;

        float min_height, max_height;

        // get_min_max_height(velodyne_set, i, 5, min_height, max_height);
        // float diff_height   = abs( min_height - max_height);


	if(velodyne_set.points[i].z < 2.0)
        {
            //float varience_1 = get_varience(feature_set, i, 7);
	    float varience_2 = get_varience_height(feature_set, velodyne_set, i, 11);
	    varience = varience_2;
	   // cout << i << " " << varience << endl;
	}
	//else
	//    varience = 1;
        //varience = get_varience_dist(feature_set, velodyne_set, i, 5);
        //varience = get_varience_height(feature_set, velodyne_set, i, 7);

        //if(varience > 0.18)
	//    varience = 1;
        feature_set[i].continuity_prob = varience;


        if(varience > max_continuity)
            max_continuity = varience;

	//if(varience != 1)
	  //  cout << i << " " << varience << endl;
    }

   // cout << endl;
    return feature_set;
}
